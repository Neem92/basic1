"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.mapTemplateLiteralToQueryText = void 0;
const shared_1 = require("@ts-safeql/shared");
const typescript_1 = __importDefault(require("typescript"));
const fp_ts_1 = require("./fp-ts");
function mapTemplateLiteralToQueryText(quasi, parser, checker, options) {
    let $idx = 0;
    let $queryText = "";
    for (const $quasi of quasi.quasis) {
        $queryText += $quasi.value.raw;
        if ($quasi.tail) {
            break;
        }
        const expression = quasi.expressions[$idx];
        const pgType = (0, fp_ts_1.pipe)(mapExpressionToTsTypeString({ expression, parser, checker }), (params) => mapTsTypeStringToPgType(Object.assign(Object.assign({}, params), { checker, options })));
        if (fp_ts_1.E.isLeft(pgType)) {
            return fp_ts_1.E.left(shared_1.InvalidQueryError.of(pgType.left, expression));
        }
        const pgTypeValue = pgType.right;
        $queryText += `$${++$idx}::${pgTypeValue}`;
    }
    return fp_ts_1.E.right($queryText);
}
exports.mapTemplateLiteralToQueryText = mapTemplateLiteralToQueryText;
function mapExpressionToTsTypeString(params) {
    const tsNode = params.parser.esTreeNodeToTSNodeMap.get(params.expression);
    const tsType = params.checker.getTypeAtLocation(tsNode);
    return {
        node: tsNode,
        type: tsType,
    };
}
const tsTypeToPgTypeMap = {
    number: "int",
    string: "text",
    boolean: "boolean",
    bigint: "bigint",
    any: "text",
    unknown: "text",
};
const tsKindToPgTypeMap = {
    [typescript_1.default.SyntaxKind.StringLiteral]: "text",
    [typescript_1.default.SyntaxKind.NumericLiteral]: "int",
    [typescript_1.default.SyntaxKind.TrueKeyword]: "boolean",
    [typescript_1.default.SyntaxKind.FalseKeyword]: "boolean",
    [typescript_1.default.SyntaxKind.BigIntLiteral]: "bigint",
};
const tsFlagToTsTypeStringMap = {
    [typescript_1.default.TypeFlags.String]: "string",
    [typescript_1.default.TypeFlags.Number]: "number",
    [typescript_1.default.TypeFlags.Boolean]: "boolean",
    [typescript_1.default.TypeFlags.BigInt]: "bigint",
    [typescript_1.default.TypeFlags.NumberLiteral]: "number",
    [typescript_1.default.TypeFlags.StringLiteral]: "string",
    [typescript_1.default.TypeFlags.BooleanLiteral]: "boolean",
    [typescript_1.default.TypeFlags.BigIntLiteral]: "bigint",
};
const tsFlagToPgTypeMap = {
    [typescript_1.default.TypeFlags.String]: "text",
    [typescript_1.default.TypeFlags.Number]: "int",
    [typescript_1.default.TypeFlags.Boolean]: "boolean",
    [typescript_1.default.TypeFlags.BigInt]: "bigint",
    [typescript_1.default.TypeFlags.NumberLiteral]: "int",
    [typescript_1.default.TypeFlags.StringLiteral]: "text",
    [typescript_1.default.TypeFlags.BooleanLiteral]: "boolean",
    [typescript_1.default.TypeFlags.BigIntLiteral]: "bigint",
};
function mapTsTypeStringToPgType(params) {
    var _a;
    if (params.node.kind === typescript_1.default.SyntaxKind.ConditionalExpression) {
        const whenTrue = params.checker.getTypeAtLocation(params.node.whenTrue);
        const whenTrueType = tsFlagToPgTypeMap[whenTrue.flags];
        const whenFalse = params.checker.getTypeAtLocation(params.node.whenFalse);
        const whenFalseType = tsFlagToPgTypeMap[whenFalse.flags];
        if (whenTrueType === undefined || whenFalseType === undefined) {
            return fp_ts_1.E.left(`Unsupported conditional expression flags (true = ${whenTrue.flags}, false = ${whenFalse.flags})`);
        }
        if (whenTrueType !== whenFalseType) {
            return fp_ts_1.E.left(`Conditional expression must have the same type (true = ${whenTrueType}, false = ${whenFalseType})`);
        }
        return fp_ts_1.E.right(whenTrueType);
    }
    if (params.node.kind === typescript_1.default.SyntaxKind.Identifier) {
        const symbol = params.checker.getSymbolAtLocation(params.node);
        const type = params.checker.getTypeOfSymbolAtLocation(symbol, params.node);
        if (isTsUnionType(type)) {
            const isUnionOfTheSameType = type.types.every((t) => t.flags === type.types[0].flags);
            const pgType = tsFlagToPgTypeMap[type.types[0].flags];
            if (!isUnionOfTheSameType || pgType === undefined) {
                return fp_ts_1.E.left(createMixedTypesInUnionErrorMessage(type.types.map((t) => t.flags)));
            }
            return fp_ts_1.E.right(pgType);
        }
    }
    if (params.node.kind in tsKindToPgTypeMap) {
        return fp_ts_1.E.right(tsKindToPgTypeMap[params.node.kind]);
    }
    if (params.type.flags in tsFlagToPgTypeMap) {
        return fp_ts_1.E.right(tsFlagToPgTypeMap[params.type.flags]);
    }
    const typeStr = params.checker.typeToString(params.type);
    const singularType = typeStr.replace(/\[\]$/, "");
    const isArray = typeStr !== singularType;
    const isSignularTypeSupported = singularType in tsTypeToPgTypeMap;
    if (isSignularTypeSupported) {
        return isArray
            ? fp_ts_1.E.right(`${tsTypeToPgTypeMap[singularType]}[]`)
            : fp_ts_1.E.right(tsTypeToPgTypeMap[singularType]);
    }
    if (((_a = params.options.overrides) === null || _a === void 0 ? void 0 : _a.types) !== undefined) {
        const override = Object.entries(params.options.overrides.types)
            .map(([key, value]) => ({ pgType: key, tsType: value }))
            .find((entry) => entry.tsType === singularType);
        if (override !== undefined) {
            return isArray ? fp_ts_1.E.right(`${override.pgType}[]`) : fp_ts_1.E.right(override.pgType);
        }
    }
    return fp_ts_1.E.left(`the type "${typeStr}" is not supported`);
}
function isTsUnionType(type) {
    return type.flags === typescript_1.default.TypeFlags.Union;
}
function createMixedTypesInUnionErrorMessage(flags) {
    const flagsAsText = flags
        .map((flag) => { var _a; return (_a = tsFlagToTsTypeStringMap[flag]) !== null && _a !== void 0 ? _a : `unknown (${flag})`; })
        .join(", ");
    return `Union types must be of the same type (found ${flagsAsText})`;
}
//# sourceMappingURL=ts-pg.utils.js.map