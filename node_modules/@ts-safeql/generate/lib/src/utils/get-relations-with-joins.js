"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.flattenRelationsWithJoinsMap = exports.getRelationsWithJoins = void 0;
function getRelationsWithJoins(parsed) {
    var _a;
    const results = new Map();
    const stmt = parsed.stmts[0];
    if (stmt === undefined || ((_a = stmt.stmt.SelectStmt) === null || _a === void 0 ? void 0 : _a.fromClause) === undefined) {
        return results;
    }
    for (const fromClause of stmt.stmt.SelectStmt.fromClause) {
        if (fromClause.JoinExpr !== undefined) {
            const { relName, joins } = recursiveTraverseJoins([], fromClause.JoinExpr);
            results.set(relName, joins);
        }
    }
    return results;
}
exports.getRelationsWithJoins = getRelationsWithJoins;
function recursiveTraverseJoins(joins, joinExpr) {
    var _a, _b, _c;
    if (((_a = joinExpr.rarg) === null || _a === void 0 ? void 0 : _a.RangeVar) !== undefined) {
        const join = { type: joinExpr.jointype, name: joinExpr.rarg.RangeVar.relname };
        if (((_b = joinExpr.larg) === null || _b === void 0 ? void 0 : _b.JoinExpr) !== undefined) {
            return recursiveTraverseJoins([join, ...joins], (_c = joinExpr.larg) === null || _c === void 0 ? void 0 : _c.JoinExpr);
        }
        return { relName: joinExpr.larg.RangeVar.relname, joins: [join, ...joins] };
    }
    return { relName: joinExpr.rarg.RangeVar.relname, joins };
}
function flattenRelationsWithJoinsMap(relationsWithJoinsMap) {
    const result = [];
    relationsWithJoinsMap.forEach((joins, relName) => {
        joins.forEach((join) => {
            result.push({ relName, joinType: join.type, joinRelName: join.name });
        });
    });
    return result;
}
exports.flattenRelationsWithJoinsMap = flattenRelationsWithJoinsMap;
//# sourceMappingURL=get-relations-with-joins.js.map