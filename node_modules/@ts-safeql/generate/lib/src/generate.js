"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createGenerator = void 0;
const shared_1 = require("@ts-safeql/shared");
const fp_ts_1 = require("fp-ts");
const postgres_1 = require("postgres");
const get_relations_with_joins_1 = require("./utils/get-relations-with-joins");
function createGenerator() {
    const cacheMap = new Map();
    return {
        generate: (params) => generate(params, cacheMap),
        dropCacheKey: (cacheKey) => cacheMap.delete(cacheKey),
        clearCache: () => cacheMap.clear(),
    };
}
exports.createGenerator = createGenerator;
async function generate(params, cacheMap) {
    var _a;
    const { sql, query, cacheMetadata = true } = params;
    const { pgColsByTableOidCache, pgTypes } = cacheMetadata
        ? await (0, shared_1.getOrSetFromMap)({
            map: cacheMap,
            key: params.cacheKey,
            value: () => getDatabaseMetadata(sql),
        })
        : await getDatabaseMetadata(sql);
    try {
        const result = await sql.unsafe(query, [], { prepare: true }).describe();
        if (result.columns === undefined || result.columns === null || result.columns.length === 0) {
            return fp_ts_1.either.right({ result: null, stmt: result, query: query });
        }
        const duplicateCols = result.columns.filter((col, index) => result.columns.find((c, i) => c.name === col.name && i != index));
        if (duplicateCols.length > 0) {
            const dupes = duplicateCols.map((col) => ({
                table: pgColsByTableOidCache.get(col.table).find((c) => c.colName === col.name).tableName,
                column: col.name,
            }));
            return fp_ts_1.either.left(shared_1.DuplicateColumnsError.of({
                queryText: query,
                columns: dupes.map((x) => `${x.table}.${x.column}`),
            }));
        }
        const relationsWithJoins = (0, get_relations_with_joins_1.flattenRelationsWithJoinsMap)((0, get_relations_with_joins_1.getRelationsWithJoins)(params.pgParsed));
        const columns = result.columns.map((col) => {
            var _a;
            const introspected = (_a = pgColsByTableOidCache
                .get(col.table)) === null || _a === void 0 ? void 0 : _a.find((x) => x.colNum === col.number);
            return introspected === undefined ? { described: col } : { described: col, introspected };
        });
        const typesMap = Object.assign(Object.assign({}, shared_1.defaultTypeMapping), (_a = params.overrides) === null || _a === void 0 ? void 0 : _a.types);
        return fp_ts_1.either.right({
            result: mapColumnAnalysisResultsToTypeLiteral({
                columns,
                pgTypes,
                relationsWithJoins,
                typesMap,
                fieldTransform: params.fieldTransform,
            }),
            stmt: result,
            query: query,
        });
    }
    catch (e) {
        if (e instanceof postgres_1.PostgresError) {
            return fp_ts_1.either.left(shared_1.PostgresError.of({
                queryText: query,
                message: e.message,
                line: e.line,
                position: e.position,
            }));
        }
        throw e;
    }
}
async function getDatabaseMetadata(sql) {
    const pgTypes = await getPgTypes(sql);
    const pgCols = await getPgCols(sql);
    const pgColsByTableOidCache = (0, shared_1.groupBy)(pgCols, "tableOid");
    return { pgTypes, pgCols, pgColsByTableOidCache };
}
function mapColumnAnalysisResultsToTypeLiteral(params) {
    const properties = params.columns.map((col) => {
        const propertySignature = mapColumnAnalysisResultToPropertySignature({
            col,
            pgTypes: params.pgTypes,
            relationsWithJoins: params.relationsWithJoins,
            typesMap: params.typesMap,
            fieldTransform: params.fieldTransform,
        });
        return `${propertySignature};`;
    });
    return `{ ${properties.join(" ")} }`;
}
function buildInterfacePropertyValue(params) {
    const isNullable = params.isNullable && ["any", "null"].includes(params.value) === false;
    return `${params.key}: ${isNullable ? `${params.value} | null` : params.value}`;
}
function isNullableDueToRelation(params) {
    const { col, relationsWithJoins } = params;
    const findByJoin = relationsWithJoins.find((x) => x.joinRelName === col.tableName);
    if (findByJoin !== undefined) {
        switch (findByJoin.joinType) {
            case "JOIN_FULL":
            case "JOIN_LEFT":
                return true;
            case "JOIN_ANTI":
            case "JOIN_INNER":
            case "JOIN_RIGHT":
            case "JOIN_SEMI":
                return false;
            default:
                (0, shared_1.assertNever)(findByJoin.joinType);
        }
    }
    const findByRel = relationsWithJoins.filter((x) => x.relName === col.tableName);
    for (const rel of findByRel) {
        switch (rel.joinType) {
            case "JOIN_RIGHT":
            case "JOIN_FULL":
                return true;
            case "JOIN_LEFT":
            case "JOIN_ANTI":
            case "JOIN_INNER":
            case "JOIN_SEMI":
                continue;
            default:
                (0, shared_1.assertNever)(rel.joinType);
        }
    }
    return false;
}
function mapColumnAnalysisResultToPropertySignature(params) {
    var _a;
    if ("introspected" in params.col) {
        const value = params.typesMap[params.col.introspected.colType];
        const key = (_a = params.col.described.name) !== null && _a !== void 0 ? _a : params.col.introspected.colName;
        const isNullable = !params.col.introspected.colNotNull || isNullableDueToRelation({
            col: params.col.introspected,
            relationsWithJoins: params.relationsWithJoins,
        });
        return buildInterfacePropertyValue({
            key: (0, shared_1.toCase)(key, params.fieldTransform),
            value: value,
            isNullable: isNullable,
        });
    }
    const nonTableColumnType = getTsTypeFromPgTypeOid({
        pgTypeOid: params.col.described.type,
        pgTypes: params.pgTypes,
        typesMap: params.typesMap,
    });
    return buildInterfacePropertyValue({
        key: (0, shared_1.toCase)(params.col.described.name, params.fieldTransform),
        value: nonTableColumnType,
        isNullable: false,
    });
}
function getTsTypeFromPgTypeOid(params) {
    const pgType = params.pgTypes.find((type) => type.oid === params.pgTypeOid);
    if (pgType === undefined) {
        return "unknown";
    }
    return getTsTypeFromPgType({ pgTypeName: pgType.name, typesMap: params.typesMap });
}
function getTsTypeFromPgType(params) {
    var _a;
    const { isArray, pgType } = parsePgType(params.pgTypeName);
    const tsType = (_a = params.typesMap[pgType]) !== null && _a !== void 0 ? _a : "any";
    return isArray ? `${tsType}[]` : tsType;
}
function isPgTypeArray(pgType) {
    return pgType.startsWith("_");
}
function parsePgType(pgType) {
    const isArray = isPgTypeArray(pgType);
    return {
        isArray: isArray,
        pgType: isArray ? pgType.slice(1) : pgType,
    };
}
async function getPgTypes(sql) {
    const rows = await sql `
        SELECT oid, typname as name FROM pg_type
    `;
    return rows;
}
async function getPgCols(sql) {
    const rows = await sql `
        SELECT
            pg_class.oid as "tableOid",
            pg_class.relname as "tableName",
            pg_attribute.attname as "colName",
            pg_type.typname as "colType",
            pg_attribute.attnum as "colNum",
            pg_attribute.atthasdef "colHasDef",
            pg_attribute.attnotnull "colNotNull"
        FROM
            pg_attribute,
            pg_class,
            pg_type
        WHERE TRUE
            AND pg_attribute.attrelid = pg_class.oid
            AND pg_attribute.atttypid = pg_type.oid
            AND pg_attribute.attnum >= 1
        ORDER BY
            pg_class.relname,
            pg_attribute.attname
    `;
    return rows;
}
//# sourceMappingURL=generate.js.map